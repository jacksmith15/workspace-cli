{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Workspace streamlines management and adoption of mono-repositories, by providing a lightweight wrapper around multi-repo tooling. It was initially implemented to manage Python projects, but can be extended to interpret other types of projects. Core concepts \u00b6 A workspace is a collection of projects, under a single root directory (usually the root directory of a git repository) Each project is equivalent to a single repository in a multi-repo strategy. It specifies its own tooling for testing, building, etc. Key features \u00b6 The CLI tool stores lightweight metadata in the repository and provides: Inter-project dependency inference Environment-aware command runner with support for parallelisation over projects Compatibility with multi-repo tooling Define and use custom templates for new projects Plugin support for custom project types Motivation \u00b6 There are many advantages to a mono-repo strategy. Some commonly mentioned ones are: Atomic changes : A system change which affects multiple components is still only a single change in source control, which reducing the number of barriers to delivery. Code reuse : Its easy to share code between different projects, as there is no need to set-up a new repository to contain the shared code. Ease of refactoring : When each project is a separate repository, its harder to redraw the boundaries of those projects. Because of this, its tempting to add new functionality in places where it doesn't belong. Cognitive overhead : If a multi-repo system grows to include a large number of components, it can be daunting for new contributors to identify and understand the wider picture, and the relationships between projects. These benefits come with some new challenges, for example: Boundaries between projects (previously implicit in the repository boundary) can become less well-defined. Smarter automation/continuous integration is required, or else changes to a single project can result in a time-consuming build cycle for all projects. Workspace tries to alleviate these challenges without impacting per-project tooling choices. Its underlying philosophy is that each project should be extricable from the wider project, so that: Project boundaries are as clear as they would be in a multi-repo strategy. Maintainers of a particular project can use the build and development tools they are familiar with. It is trivial to migrate projects in (and out) of the mono-repo.","title":"Home"},{"location":"#home","text":"Workspace streamlines management and adoption of mono-repositories, by providing a lightweight wrapper around multi-repo tooling. It was initially implemented to manage Python projects, but can be extended to interpret other types of projects.","title":"Home"},{"location":"#core-concepts","text":"A workspace is a collection of projects, under a single root directory (usually the root directory of a git repository) Each project is equivalent to a single repository in a multi-repo strategy. It specifies its own tooling for testing, building, etc.","title":"Core concepts"},{"location":"#key-features","text":"The CLI tool stores lightweight metadata in the repository and provides: Inter-project dependency inference Environment-aware command runner with support for parallelisation over projects Compatibility with multi-repo tooling Define and use custom templates for new projects Plugin support for custom project types","title":"Key features"},{"location":"#motivation","text":"There are many advantages to a mono-repo strategy. Some commonly mentioned ones are: Atomic changes : A system change which affects multiple components is still only a single change in source control, which reducing the number of barriers to delivery. Code reuse : Its easy to share code between different projects, as there is no need to set-up a new repository to contain the shared code. Ease of refactoring : When each project is a separate repository, its harder to redraw the boundaries of those projects. Because of this, its tempting to add new functionality in places where it doesn't belong. Cognitive overhead : If a multi-repo system grows to include a large number of components, it can be daunting for new contributors to identify and understand the wider picture, and the relationships between projects. These benefits come with some new challenges, for example: Boundaries between projects (previously implicit in the repository boundary) can become less well-defined. Smarter automation/continuous integration is required, or else changes to a single project can result in a time-consuming build cycle for all projects. Workspace tries to alleviate these challenges without impacting per-project tooling choices. Its underlying philosophy is that each project should be extricable from the wider project, so that: Project boundaries are as clear as they would be in a multi-repo strategy. Maintainers of a particular project can use the build and development tools they are familiar with. It is trivial to migrate projects in (and out) of the mono-repo.","title":"Motivation"},{"location":"basic-usage/","text":"Basic usage \u00b6 Start a new workspace \u00b6 You can create a new workspace in the current working directory: workspace init Created workspace at /current/working/directory. Info You can also specify the path to the workspace using the --path option. This creates a file called workspace.json , which contains metadata about the workspace. This file marks the root directory of the workspace. When detecting the active workspace, the CLI looks for a workspace.json file in the current directory first, followed by its parents. Info To display the current workspace path, run workspace info . Managing projects \u00b6 Creating a project from scratch \u00b6 A workspace contains one or more projects. You can create a new project with workspace new : workspace new --type poetry libs/library-one Created new project library-one at libs/library-one. Info This creates a Poetry project at the specified path. For other types of project, see Project types below. We can check this project exists by listing all projects in the workspace: workspace list Name: library-one Type: poetry Path: /path/to/workspace/libs/library-one Dependencies: [] Info The name above was auto-generated from the directory name of the project. To specify a custom name, pass the --name flag to workspace new or workspace add . Adding an existing project \u00b6 If you already have an existing project, add it to be tracked by the workspace: workspace add libs/library-two Added new project library-two at libs/library-two. Info We didn't specify --type here, because the CLI will attempt to automatically detect from the available types . If the wrong type is detected, you can specify this explicitly. Removing a project \u00b6 To stop tracking a workspace: workspace remove library-one Stopped tracking projects: - library-one Warning This will not delete anything by default. To delete the project directory, pass the --delete flag. Listing projects \u00b6 To show information about all projects, use workspace list : workspace list Name: library-one Type: poetry Path: /path/to/workspace/libs/library-one Dependencies: [] Name: library-two Type: poetry Path: /path/to/workspace/libs/library-two Dependencies: [] Tip This command (and others) support alternative output formats, including json. Run workspace list --help for more information. Tip You can pass or pipe project names (or globbed names) to list a subset of projects. This can be combined with other commands which only output project names, to show more information about them. Project environments \u00b6 Each project will have some environment, containing their dependencies. You can synchronise those environments for all projects at once, using: workspace sync --dev --parallel Running poetry install \u2714 library-two (0.8s) \u2714 library-one (0.8s) In the case of Poetry projects, this runs poetry install to prepare each project's virtual environment . Other project types will perform other tasks. Running commands \u00b6 Arbitrary commands can be run in every tracked project in parallel, ensuring that each uses their respective environments: workspace run -c 'pytest' --parallel Running pytest \u2714 library-two (0.5s) \u2714 library-one (0.6s) Tip The above command runs tests in parallel, which will only write command output if a command fails. To see the output of each command, omit the --parallel flag. To run commands in specific projects, provide their names as positional arguments: workspace run -c 'pytest' library-one library-two Example workspace run supports piping a list of target project names, as well globbed names, for example: echo \"library-*\" | workspace run -c 'pytest' Dependency inference \u00b6 Projects in a workspace will often depend on each other. This can be inspected with the appropriate commands: workspace dependencies library-two library-two library-one workspace dependees library-one library-one library-two Info Both of the above commands will traverse all transitive dependencies. To show only direct dependencies or dependees, pass the --no-transitive flag. Tip Pass multiple inputs to output the union of results. As with run , piped and globbed arguments can be used. To identify which project a particular file belongs to, use workspace reverse : workspace reverse libs/library-one/pyproject.toml library-one Tip Combine run , dependees and reverse to run tests on only the affected projects of a git diff: git --no-pager diff --name-only |\\ workspace reverse |\\ workspace dependees |\\ workspace run -c 'pytest' Project types \u00b6 Every project in a workspace has a \"type\", which defines how the CLI interacts with that project and its environment. By default, two types are supported Poetry and Pipenv , both of which manage Python project environments. Additional types can be added via plugins .","title":"Basic usage"},{"location":"basic-usage/#basic-usage","text":"","title":"Basic usage"},{"location":"basic-usage/#start-a-new-workspace","text":"You can create a new workspace in the current working directory: workspace init Created workspace at /current/working/directory. Info You can also specify the path to the workspace using the --path option. This creates a file called workspace.json , which contains metadata about the workspace. This file marks the root directory of the workspace. When detecting the active workspace, the CLI looks for a workspace.json file in the current directory first, followed by its parents. Info To display the current workspace path, run workspace info .","title":"Start a new workspace"},{"location":"basic-usage/#managing-projects","text":"","title":"Managing projects"},{"location":"basic-usage/#creating-a-project-from-scratch","text":"A workspace contains one or more projects. You can create a new project with workspace new : workspace new --type poetry libs/library-one Created new project library-one at libs/library-one. Info This creates a Poetry project at the specified path. For other types of project, see Project types below. We can check this project exists by listing all projects in the workspace: workspace list Name: library-one Type: poetry Path: /path/to/workspace/libs/library-one Dependencies: [] Info The name above was auto-generated from the directory name of the project. To specify a custom name, pass the --name flag to workspace new or workspace add .","title":"Creating a project from scratch"},{"location":"basic-usage/#adding-an-existing-project","text":"If you already have an existing project, add it to be tracked by the workspace: workspace add libs/library-two Added new project library-two at libs/library-two. Info We didn't specify --type here, because the CLI will attempt to automatically detect from the available types . If the wrong type is detected, you can specify this explicitly.","title":"Adding an existing project"},{"location":"basic-usage/#removing-a-project","text":"To stop tracking a workspace: workspace remove library-one Stopped tracking projects: - library-one Warning This will not delete anything by default. To delete the project directory, pass the --delete flag.","title":"Removing a project"},{"location":"basic-usage/#listing-projects","text":"To show information about all projects, use workspace list : workspace list Name: library-one Type: poetry Path: /path/to/workspace/libs/library-one Dependencies: [] Name: library-two Type: poetry Path: /path/to/workspace/libs/library-two Dependencies: [] Tip This command (and others) support alternative output formats, including json. Run workspace list --help for more information. Tip You can pass or pipe project names (or globbed names) to list a subset of projects. This can be combined with other commands which only output project names, to show more information about them.","title":"Listing projects"},{"location":"basic-usage/#project-environments","text":"Each project will have some environment, containing their dependencies. You can synchronise those environments for all projects at once, using: workspace sync --dev --parallel Running poetry install \u2714 library-two (0.8s) \u2714 library-one (0.8s) In the case of Poetry projects, this runs poetry install to prepare each project's virtual environment . Other project types will perform other tasks.","title":"Project environments"},{"location":"basic-usage/#running-commands","text":"Arbitrary commands can be run in every tracked project in parallel, ensuring that each uses their respective environments: workspace run -c 'pytest' --parallel Running pytest \u2714 library-two (0.5s) \u2714 library-one (0.6s) Tip The above command runs tests in parallel, which will only write command output if a command fails. To see the output of each command, omit the --parallel flag. To run commands in specific projects, provide their names as positional arguments: workspace run -c 'pytest' library-one library-two Example workspace run supports piping a list of target project names, as well globbed names, for example: echo \"library-*\" | workspace run -c 'pytest'","title":"Running commands"},{"location":"basic-usage/#dependency-inference","text":"Projects in a workspace will often depend on each other. This can be inspected with the appropriate commands: workspace dependencies library-two library-two library-one workspace dependees library-one library-one library-two Info Both of the above commands will traverse all transitive dependencies. To show only direct dependencies or dependees, pass the --no-transitive flag. Tip Pass multiple inputs to output the union of results. As with run , piped and globbed arguments can be used. To identify which project a particular file belongs to, use workspace reverse : workspace reverse libs/library-one/pyproject.toml library-one Tip Combine run , dependees and reverse to run tests on only the affected projects of a git diff: git --no-pager diff --name-only |\\ workspace reverse |\\ workspace dependees |\\ workspace run -c 'pytest'","title":"Dependency inference"},{"location":"basic-usage/#project-types","text":"Every project in a workspace has a \"type\", which defines how the CLI interacts with that project and its environment. By default, two types are supported Poetry and Pipenv , both of which manage Python project environments. Additional types can be added via plugins .","title":"Project types"},{"location":"configuration/","text":"Configuration \u00b6 Global configuration \u00b6 Global configuration is read from environment variables. Name Default Description WORKSPACE_FILENAME workspace.json Filename to search for when detecting workspaces. Workspace configuration \u00b6 The contents of workspace.json is primarily configured via CLI. It supports the following fields: Field Required Type Description projects yes object A mapping of name to project metadata. plugins no array List of enabled plugins as Python module paths. template_path no array List of paths to detect templates.","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#global-configuration","text":"Global configuration is read from environment variables. Name Default Description WORKSPACE_FILENAME workspace.json Filename to search for when detecting workspaces.","title":"Global configuration"},{"location":"configuration/#workspace-configuration","text":"The contents of workspace.json is primarily configured via CLI. It supports the following fields: Field Required Type Description projects yes object A mapping of name to project metadata. plugins no array List of enabled plugins as Python module paths. template_path no array List of paths to detect templates.","title":"Workspace configuration"},{"location":"faq/","text":"FAQ \u00b6 Why not Bazel , Buck , Pants , or Please ? \u00b6 Bazel , Buck , Pants and Please are all powerful build tools, with feature sets that overlap with Workspace. They give (usually) lightning-fast and reproducible builds, but dictate to some degree how projects should be structured. In contrast, Workspace is not a build tool. It has no opinions about how individual projects should be tested and built, or how the respective tooling for each project should be configured. In a sense, Workspace lowers the barrier to entry for mono-repositories, by providing a lightweight abstraction layer around existing multi-repo processes rather than an entire build-system.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#why-not-bazel-buck-pants-or-please","text":"Bazel , Buck , Pants and Please are all powerful build tools, with feature sets that overlap with Workspace. They give (usually) lightning-fast and reproducible builds, but dictate to some degree how projects should be structured. In contrast, Workspace is not a build tool. It has no opinions about how individual projects should be tested and built, or how the respective tooling for each project should be configured. In a sense, Workspace lowers the barrier to entry for mono-repositories, by providing a lightweight abstraction layer around existing multi-repo processes rather than an entire build-system.","title":"Why not Bazel, Buck, Pants, or Please?"},{"location":"installation/","text":"Installation \u00b6 pip install workspace-cli Tip You can specify extras to ensure all functionality is enabled: $ pip install workspace-cli[pipenv,poetry,cookiecutter]","title":"Installation"},{"location":"installation/#installation","text":"pip install workspace-cli Tip You can specify extras to ensure all functionality is enabled: $ pip install workspace-cli[pipenv,poetry,cookiecutter]","title":"Installation"},{"location":"plugins/","text":"Plugins \u00b6 By default, two types of project are supported: poetry and pipenv . New types can be added by enabling plugins which contain adapters for those project types. A plugin is simply a Python module containing one or more subclasses of workspace.core.adapter.Adapter , which must implement its abstract methods. Adding plugins \u00b6 Expand the following to see an example plugin for Python projects using requirements.txt files: plugins/requirementstxt.py import os import shlex import subprocess from typing import Set , Tuple import requirements from workspace.core.adapter import Adapter class RequirementsTXTAdapter ( Adapter , name = \"requirementstxt\" ): def validate ( self ): \"\"\"Attempt to parse the requirements.\"\"\" _ = self . _requirements def run_args ( self , command : str ) -> Tuple [ str , dict ]: \"\"\"Get modified command and kwargs that should be used when running inside the project.\"\"\" command , kwargs = super () . run_args ( command ) venv_path = self . _ensure_virtualenv () env = os . environ . copy () env [ \"VIRTUAL_ENV\" ] = str ( venv_path ) env [ \"PATH\" ] = f \" { venv_path / 'bin' } : { env [ 'PATH' ] } \" kwargs [ \"env\" ] = env return command , kwargs def sync ( self , include_dev : bool = True ) -> subprocess . CompletedProcess : \"\"\"Sync dependencies of the project.\"\"\" command = [ \"pip\" , \"install\" , \"-r\" , \"requirements.txt\" ] if include_dev : command . extend ([ \"-r\" , \"requirements-dev.txt\" ]) return self . run ( shlex . join ( command )) def dependencies ( self , include_dev : bool = True ) -> Set [ str ]: \"\"\"Get other workspaces this project depends upon.\"\"\" deps = self . _requirements [ \"default\" ] if include_dev : deps . extend ( self . _requirements [ \"dev\" ]) results = set () for dep in deps : if dep . editable : path = ( self . _project . resolved_path / dep . path ) . resolve () project = self . _project . root . get_project_by_path ( path ) if project : results . add ( project . name ) return results @property def _requirements ( self ): \"\"\"Parse the requirements files.\"\"\" return { \"default\" : list ( requirements . parse (( self . _project . resolved_path / \"requirements.txt\" ) . read_text ())), \"dev\" : list ( requirements . parse (( self . _project . resolved_path / \"requirements-dev.txt\" ) . read_text ())), } def _ensure_virtualenv ( self ): \"\"\"Ensure virtualenv exists.\"\"\" venv_path = self . _project . resolved_path / \".venv\" if not ( venv_path / \"bin/python\" ) . exists (): subprocess . run ([ \"python\" , \"-m\" , \"venv\" , venv_path ], check = True ) return venv_path Provided the above example is on the PYTHONPATH , it can be enabled using workspace plugin add plugins.requirementstxt Added plugin plugins.requirementstxt. The following new project types are now available: - requirementstxt Projects using requirements.txt files can then be added to the workspace. Showing currently enabled plugins \u00b6 The currently enabled plugins can be shown using: workspace plugin list plugins.requirementstxt Disabling plugins \u00b6 Plugins can be disabled using: workspace plugin remove plugins.requirementstxt Removed plugin plugins.requirementstxt. Warning Ensure that no projects use types enabled by a plugin before disabling it, or the workspace will not be able to interact with the project.","title":"Plugins"},{"location":"plugins/#plugins","text":"By default, two types of project are supported: poetry and pipenv . New types can be added by enabling plugins which contain adapters for those project types. A plugin is simply a Python module containing one or more subclasses of workspace.core.adapter.Adapter , which must implement its abstract methods.","title":"Plugins"},{"location":"plugins/#adding-plugins","text":"Expand the following to see an example plugin for Python projects using requirements.txt files: plugins/requirementstxt.py import os import shlex import subprocess from typing import Set , Tuple import requirements from workspace.core.adapter import Adapter class RequirementsTXTAdapter ( Adapter , name = \"requirementstxt\" ): def validate ( self ): \"\"\"Attempt to parse the requirements.\"\"\" _ = self . _requirements def run_args ( self , command : str ) -> Tuple [ str , dict ]: \"\"\"Get modified command and kwargs that should be used when running inside the project.\"\"\" command , kwargs = super () . run_args ( command ) venv_path = self . _ensure_virtualenv () env = os . environ . copy () env [ \"VIRTUAL_ENV\" ] = str ( venv_path ) env [ \"PATH\" ] = f \" { venv_path / 'bin' } : { env [ 'PATH' ] } \" kwargs [ \"env\" ] = env return command , kwargs def sync ( self , include_dev : bool = True ) -> subprocess . CompletedProcess : \"\"\"Sync dependencies of the project.\"\"\" command = [ \"pip\" , \"install\" , \"-r\" , \"requirements.txt\" ] if include_dev : command . extend ([ \"-r\" , \"requirements-dev.txt\" ]) return self . run ( shlex . join ( command )) def dependencies ( self , include_dev : bool = True ) -> Set [ str ]: \"\"\"Get other workspaces this project depends upon.\"\"\" deps = self . _requirements [ \"default\" ] if include_dev : deps . extend ( self . _requirements [ \"dev\" ]) results = set () for dep in deps : if dep . editable : path = ( self . _project . resolved_path / dep . path ) . resolve () project = self . _project . root . get_project_by_path ( path ) if project : results . add ( project . name ) return results @property def _requirements ( self ): \"\"\"Parse the requirements files.\"\"\" return { \"default\" : list ( requirements . parse (( self . _project . resolved_path / \"requirements.txt\" ) . read_text ())), \"dev\" : list ( requirements . parse (( self . _project . resolved_path / \"requirements-dev.txt\" ) . read_text ())), } def _ensure_virtualenv ( self ): \"\"\"Ensure virtualenv exists.\"\"\" venv_path = self . _project . resolved_path / \".venv\" if not ( venv_path / \"bin/python\" ) . exists (): subprocess . run ([ \"python\" , \"-m\" , \"venv\" , venv_path ], check = True ) return venv_path Provided the above example is on the PYTHONPATH , it can be enabled using workspace plugin add plugins.requirementstxt Added plugin plugins.requirementstxt. The following new project types are now available: - requirementstxt Projects using requirements.txt files can then be added to the workspace.","title":"Adding plugins"},{"location":"plugins/#showing-currently-enabled-plugins","text":"The currently enabled plugins can be shown using: workspace plugin list plugins.requirementstxt","title":"Showing currently enabled plugins"},{"location":"plugins/#disabling-plugins","text":"Plugins can be disabled using: workspace plugin remove plugins.requirementstxt Removed plugin plugins.requirementstxt. Warning Ensure that no projects use types enabled by a plugin before disabling it, or the workspace will not be able to interact with the project.","title":"Disabling plugins"},{"location":"templates/","text":"Templates \u00b6 The CLI has in-built support for using custom cookiecutter templates to create new projects in your workspace. Template path \u00b6 Given a templates/ directory contains some templates: WORKSPACE_ROOT/ templates/ library-template/ application-template/ workspace.json Make these templates available by adding the directory to the template path : workspace template path add templates/ Added templates to available template directories. Tip Any templates added to the directory above will automatically be available to the workspace. Inspect the available templates with: workspace template list library-template templates/library-template application-template templates/application-template Info Multiple directories can be added to the template path. To inspect the current template path, use workspace info . Using templates \u00b6 Available templates can be used to create a new projects: workspaces new --template library-template libs/my-new-library Created new project my-new-library at libs/my-new-library. Tip Ensure cookiecutter is installed with pip install workspace-cli[cookiecutter] . Default variables \u00b6 Some additional variables can be automatically made available to project templates: {{ workspace_project_path }} is the relative path of the project from the workspace root. {{ workspace_project_name }} is the name of the project in the workspace. To make these available, include them in the template's cookiecutter.json file, e.g. { \"workspace_project_path\" : null , \"workspace_project_name\" : null } Warning Encoding these in a project creates coupling between the project and the workspace.","title":"Templates"},{"location":"templates/#templates","text":"The CLI has in-built support for using custom cookiecutter templates to create new projects in your workspace.","title":"Templates"},{"location":"templates/#template-path","text":"Given a templates/ directory contains some templates: WORKSPACE_ROOT/ templates/ library-template/ application-template/ workspace.json Make these templates available by adding the directory to the template path : workspace template path add templates/ Added templates to available template directories. Tip Any templates added to the directory above will automatically be available to the workspace. Inspect the available templates with: workspace template list library-template templates/library-template application-template templates/application-template Info Multiple directories can be added to the template path. To inspect the current template path, use workspace info .","title":"Template path"},{"location":"templates/#using-templates","text":"Available templates can be used to create a new projects: workspaces new --template library-template libs/my-new-library Created new project my-new-library at libs/my-new-library. Tip Ensure cookiecutter is installed with pip install workspace-cli[cookiecutter] .","title":"Using templates"},{"location":"templates/#default-variables","text":"Some additional variables can be automatically made available to project templates: {{ workspace_project_path }} is the relative path of the project from the workspace root. {{ workspace_project_name }} is the name of the project in the workspace. To make these available, include them in the template's cookiecutter.json file, e.g. { \"workspace_project_path\" : null , \"workspace_project_name\" : null } Warning Encoding these in a project creates coupling between the project and the workspace.","title":"Default variables"}]}